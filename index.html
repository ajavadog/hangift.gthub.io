<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>聖誕炸涵單</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-image: url('san.jpg');
      background-size: cover;
    }

    #player {
      position: absolute;
      bottom: 0;
      left: 50vw;
      transform: translateX(-50%);
      width: 120px;
      height: 120px;
      background-image: url('q_character.png');
      background-size: cover;
    }

    .bomb {
      position: absolute;
      width: 120px;
      height: 120px;
      background-image: url('q_bomb.png');
      background-size: cover;
      border-radius: 50%; /* 添加圓角，使碰撞判定區域更貼合圖片形狀 */
    }
  </style>
</head>
<body>
  <div id="player"></div>

  <script>
    const player = document.getElementById('player');
    let isJumping = false;
    let jumpCount = 0;
    let score = 0;

    function createBomb() {
      removeAllBombs();

      const bomb = document.createElement('div');
      bomb.className = 'bomb';
      bomb.style.left = Math.random() * window.innerWidth + 'px';
      document.body.appendChild(bomb);

      function fall() {
        const top = bomb.offsetTop;
        bomb.style.top = top + 5 + 'px';

        if (top > window.innerHeight) {
          document.body.removeChild(bomb);
          requestAnimationFrame(() => createBomb());
        } else {
          checkCollision(bomb);
          requestAnimationFrame(fall);
        }
      }

      requestAnimationFrame(fall);
    }

    function checkCollision(bomb) {
      const playerRect = player.getBoundingClientRect();
      const bombRect = bomb.getBoundingClientRect();

      // 調整碰撞檢測邏輯，使其更貼合圖片形狀
      if (
        playerRect.bottom > bombRect.top + 30 &&
        playerRect.top < bombRect.bottom - 30 &&
        playerRect.right > bombRect.left + 30 &&
        playerRect.left < bombRect.right - 30
      ) {
        alert('遊戲結束！得分：' + score);
        resetGame();
      }
    }

    function resetGame() {
      isJumping = false;
      jumpCount = 0;
      score = 0;
      player.style.bottom = 0;
      removeAllBombs();
      setTimeout(() => gameLoop(), 1000);
    }

    function removeAllBombs() {
      const bombs = document.querySelectorAll('.bomb');
      bombs.forEach(bomb => bomb.parentNode.removeChild(bomb));
    }

    function jump() {
      if (!isJumping) {
        isJumping = true;
        jumpCount++;

        if (jumpCount <= 2) {
          jumpAnimation();
        }
      }
    }

    function jumpAnimation() {
      let jumpHeight = 100;
      const startTime = performance.now();

      function animate() {
        const currentTime = performance.now();
        const progress = (currentTime - startTime) / 500;

        if (progress < 1) {
          const bottom = jumpHeight * Math.sin(progress * Math.PI);
          player.style.bottom = bottom + 'px';
          requestAnimationFrame(animate);
        } else {
          fall();
        }
      }

      animate();
    }

    function fall() {
      isJumping = false;

      const fallInterval = setInterval(() => {
        const bottom = player.style.bottom ? parseInt(player.style.bottom) : 0;

        if (bottom > 0) {
          player.style.bottom = (bottom - 5) + 'px';
        } else {
          clearInterval(fallInterval);
          jumpCount = 0;
        }
      }, 16);
    }

    function gameLoop() {
      createBomb();
      score++;
    }

    document.addEventListener('keydown', (event) => {
      if (event.key === 'ArrowLeft' && player.offsetLeft > 0) {
        movePlayer(-15);
      } else if (event.key === 'ArrowRight' && player.offsetLeft + player.offsetWidth < window.innerWidth) {
        movePlayer(15);
      } else if (event.key === 'ArrowUp') {
        jump();
      }
    });

    function movePlayer(deltaX) {
      const left = player.style.left ? parseInt(player.style.left) : window.innerWidth / 2;
      const newLeft = left + deltaX;

      if (!isNaN(left) && newLeft >= 0 && newLeft + player.offsetWidth <= window.innerWidth) {
        player.style.left = newLeft + 'px';
      }
    }

    setInterval(gameLoop, 1000);

  </script>
</body>
</html>
